---
title: "Important Variables Selfing"
author: "Edward Chen"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE, message = false, warning=FALSE}
library("dplyr")
library("ggplot2")
library("reshape2")
library("impute")
library("e1071") # SVM
library("Metrics")
library("rpart")
library("rpart.plot")
library("e1071")
library("caTools")
set.seed(1)
```

```{r}
raw_seed_data <- read.csv("Soper_Gorden_Adler_AJB_2018_Flower_Insect_Interactions_Raw_Seed_Data.csv")
preprocessed_data <- read.csv("Soper_Gorden_Adler_AJB_2018_Flower_Insect_Interactions_Processed_Data.csv")
```

```{r, warning=FALSE}
# Identify character variables
char_vars <- sapply(preprocessed_data, is.character)

# Convert character variables to factors
preprocessed_data[char_vars] <- lapply(preprocessed_data[char_vars], as.factor)

# Calculate the percentage of missing values in each row
missing_pct <- rowMeans(is.na(preprocessed_data))

# Identify rows with 50% or more missing values
missing_rows <- which(missing_pct >= 0.5)

# Remove rows with 50% or more missing values
preprocessed_data <- preprocessed_data[-missing_rows, ]

# Identify categorical variables
categorical_vars <- sapply(preprocessed_data, is.factor)

# Remove categorical variables
preprocessed_data <- preprocessed_data[, !categorical_vars]
preprocessed_data <- preprocessed_data %>% select(-Plot_Number)

# Set the value of k (number of neighbors)
k <- 3

# Convert the data frame to a matrix
preprocessed_data_matrix <- as.matrix(preprocessed_data)

# Perform kNN imputation
imputed_data_matrix <- impute.knn(preprocessed_data_matrix, k = k)$data

# Convert the imputed matrix back to a data frame
processed_data <- as.data.frame(imputed_data_matrix)
```

```{r}
# Remove clearly correlated variables to remove redundancy through feature selection
processed_data <- processed_data %>% select(-Proportion_of_Fruits_CH, -Mature_CH_Fruits_Per_Day, -Mature_CL_Fruits_Per_Day, -Average_CH_Fruits_Per_Day, -Average_CL_Fruits_Per_Day, -Average_CH_Flowers_Per_Day, -Total_CH_Flower_Production, -Average_CL_Flowers_Per_Day, -Average_Seeds_Per_CH_Fruit, -Average_Seeds_Per_CL_Fruit, -Average_CH_Seed_Mass, -Average_CL_Seed_Mass)
```

```{r,fig.height=8,fig.width=10, warning=FALSE}
# Check correlation between the variables
# Create a correlation matrix from the dataframe
cor_matrix <- cor(processed_data)

# Melt the correlation matrix into a long format
melted_matrix <- melt(cor_matrix)

# Create the heatmap
ggplot(melted_matrix, aes(x=Var1, y=Var2, fill=value)) +
  geom_tile() +
  scale_fill_gradient2(low="blue", mid="white", high="red", midpoint=0) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
  axis.text.y = element_text(color = ifelse(melted_matrix$Var1 == "Ratio_of_CH_to_CL_Fruits", "red", "black"))) +
  labs(title="Correlation Heatmap", x="", y="")
```

```{r}
# Calculate the mean of the "Ratio_of_CH_to_CL_Fruits" column
mean_ratio <- mean(processed_data$Ratio_of_CH_to_CL_Fruits)

# Create a histogram and add the mean as a vertical line with its value
ggplot(processed_data, aes(x = Ratio_of_CH_to_CL_Fruits)) +
  geom_histogram(aes(y = after_stat(density)), bins = 30, fill = "blue", color = "black", alpha = 0.5) +
  geom_vline(aes(xintercept = mean_ratio), color = "red", linetype = "dashed", size = 1) +
  annotate("text", x = mean_ratio, y = 0, label = paste("Mean =", round(mean_ratio, 2)), 
           vjust = -1, color = "red", fontface = "bold") +
  labs(x = "Ratio of CH to CL Fruits", y = "Density", title = "Histogram of Ratio of CH to CL Fruits with Mean")
```

```{r}
# Create a histogram and add the mean as a vertical line with its value
ggplot(processed_data, aes(x = Ratio_of_CH_to_CL_Fruits)) +
  geom_histogram(aes(y = after_stat(density)), bins = 30, fill = "blue", color = "black", alpha = 0.5) +
  geom_vline(aes(xintercept = mean_ratio), color = "red", linetype = "dashed", size = 1) +
  annotate("text", x = mean_ratio, y = 0, label = paste("Mean =", round(mean_ratio, 2)), 
           vjust = -1, color = "red", fontface = "bold") +
  labs(x = "Ratio of CH to CL Fruits", y = "Density", title = "Histogram of Ratio of CH to CL Fruits with Mean")
```

```{r}
# Perform PCA on the dataset
pca <- prcomp(processed_data, center = TRUE, scale. = TRUE)

# Extract principal components
PC1 <- pca$x[,1]
PC2 <- pca$x[,2]

# Calculate the percentage of variance explained by each principal component
pca_var <- (pca$sdev^2) / sum(pca$sdev^2)
pca_var_percentage <- pca_var * 100

# Create PCA plot with color based on "Ratio_of_CH_to_CL_Fruits"
ggplot(processed_data, aes(x = PC1, y = PC2, color = Ratio_of_CH_to_CL_Fruits)) + 
  geom_point() +
  scale_color_gradient(low = "blue", high = "red") +
  labs(x = paste0("PC1 (", round(pca_var_percentage[1], 2), "%)"), 
       y = paste0("PC2 (", round(pca_var_percentage[2], 2), "%)"), 
       title = "PCA Plot")
```

```{r}

# Calculate the mean of the "Ratio_of_CH_to_CL_Fruits" column
mean_ratio <- mean(processed_data$Ratio_of_CH_to_CL_Fruits)

# Create a binary group column based on the condition (>1.95, <1.95)
processed_data$Binary_Group <- ifelse(processed_data$Ratio_of_CH_to_CL_Fruits > mean_ratio, ">1.95", "<1.95")

# Create PCA plot with color based on binary groups
ggplot(processed_data, aes(x = PC1, y = PC2, color = Binary_Group)) + 
  geom_point() +
  scale_color_manual(values = c("<1.95" = "blue", ">1.95" = "red"), name = "Binary Group") +
  labs(x = paste0("PC1 (", round(pca_var_percentage[1], 2), "%)"), 
       y = paste0("PC2 (", round(pca_var_percentage[2], 2), "%)"), 
       title = "PCA Plot") 
```
```{r}
# Calculate the mean value of the Ratio_of_CH_to_CL_Fruits variable
mean_ratio <- mean(processed_data$Ratio_of_CH_to_CL_Fruits)

# Create a new binary_response variable in the processed_data dataframe based on whether the Ratio_of_CH_to_CL_Fruits variable is greater than the mean value
processed_data$binary_response <- ifelse(processed_data$Ratio_of_CH_to_CL_Fruits > mean_ratio, 1, 0)

# Remove the Ratio_of_CH_to_CL_Fruits and Binary_Group variables from the processed_data dataframe
processed_data <- processed_data %>% select(-Ratio_of_CH_to_CL_Fruits, -Binary_Group)

# Split the processed_data dataframe into training and test sets using a 70/30 split ratio
set.seed(123)
split <- sample.split(processed_data$binary_response, SplitRatio = 0.7)
train <- processed_data[split,]
test <- processed_data[!split,]

# Train an SVM model on the training data using a linear kernel and cost parameter of 1
svm_model <- svm(binary_response ~ ., data = train, kernel = "linear", type = "C-classification", cost = 1)

# Make predictions on the test data using the trained SVM model
predictions <- predict(svm_model, newdata = test)

# Create a confusion matrix to evaluate the performance of the model
table(predictions, test$binary_response)
```

```{r}
# Create a confusion matrix to evaluate the performance of the model
confusion_matrix <- table(predictions, test$binary_response)

# Calculate accuracy
accuracy <- sum(diag(confusion_matrix))/sum(confusion_matrix)
cat("Accuracy:", round(accuracy, 3), "\n")

# Calculate precision
precision <- confusion_matrix[2, 2]/sum(confusion_matrix[, 2])
cat("Precision:", round(precision, 3), "\n")

# Calculate recall
recall <- confusion_matrix[2, 2]/sum(confusion_matrix[2, ])
cat("Recall:", round(recall, 3), "\n")

# Calculate F1-score
f1_score <- 2 * (precision * recall) / (precision + recall)
cat("F1-score:", round(f1_score, 3), "\n")
```


```{r, fig.width = 10, fig.height = 8}
# Build the decision tree model
dt_model <- rpart(binary_response ~ ., data = processed_data, method = "class")

# Plot the decision tree
plot(dt_model)
text(dt_model, use.n = TRUE, all = TRUE, cex = 0.7)
```

```{r}
# Make predictions on the test set
dt_predictions <- predict(dt_model, newdata = test, type = "class")

# Create a confusion matrix to evaluate the performance of the model
confusion_matrix <- table(dt_predictions, test$binary_response)

# Calculate accuracy, precision, recall, and F1-score
accuracy <- sum(diag(confusion_matrix))/sum(confusion_matrix)
precision <- confusion_matrix[2, 2]/sum(confusion_matrix[, 2])
recall <- confusion_matrix[2, 2]/sum(confusion_matrix[2, ])
f1_score <- 2 * (precision * recall) / (precision + recall)

# Print the performance metrics
cat("Decision tree performance metrics:\n")
cat("Accuracy:", round(accuracy, 3), "\n")
cat("Precision:", round(precision, 3), "\n")
cat("Recall:", round(recall, 3), "\n")
cat("F1-score:", round(f1_score, 3), "\n")
```